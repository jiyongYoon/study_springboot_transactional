### 실무에서 발생했던 Transaction 격리 및 전파에 대한 이슈 도식화 작업

---
업무 도중 더티체킹 작업이 DB에 반영이 되지 않는 이슈가 있었다.

코드 흐름은 아래와 같았다.

```text
- 일정 시간마다 스케쥴러 메서드 `A`가 실행된다.
- `A`는 `@Transactional`이 없는 메서드이다.
- 메서드에서 호출하는 다른 클래스의 메서드 `B`는 `@Transactional`이 있는 메서드이다.

[로직 순서]
1. `A` 메서드에서 RDB의 File Entity들을 불러온다.
2. 리스트를 순회하며 File Entity를 매개변수로 한 메서드 `B`를 실행한다.
3. `B`의 작업이 모두 잘 수행되면 결과값을 보고 `A` 메서드에서 File Entity의 상태값을 변경한다. (더티체킹 사용)  
```

`A` 메서드에서 더티체킹이 되어 RDB에 반영이 되어야 한다고 생각했지만, 값은 변경되나 DB에 커밋이 되지 않았다.

트랜잭션의 문제임을 인지하고 여러가지 테스트를 해보고, 해당 내용을 도식화 하여 `MyExampleTest1` 클래스에 테스트 코드를 작성해두었다.

---

### 결론

- 트랜잭션이 없는 메서드에서는 `jpaRepository.save()`와 같은 메서드 호출 시 해당 메서드로 트랜잭션이 시작 후 DB에 커밋을 하고 트랜잭션이 종료된다.


- 물리 트랜잭션이 커밋 되기 위해서는 내부의 모든 논리 트랜잭션이 커밋되어야 한다.


- `B` 메서드의 작업이 수행되는 내용을 보고 `A` 메서드의 작업은 따로 진행을 하기 위해서는 서로 트랜잭션이 분리되어야 한다. 
  => `@Transactional(propagation = Propagation.REQUIRES_NEW)` 필요